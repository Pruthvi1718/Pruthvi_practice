1. HIGHER ORDER FUNCTIONS:
Higher order function are important concept of javascript,
it takes function as a argument return function as a result.
It enables function composition, currying and lazy evaluation.

Function Composition:
It means combining two or more functions so that the output of one function
becomes the input of another function.
example:
const add = x => x + 2;
const multiply = x => x * 3;
const result = multiply(add(5));
console.log(result);

Currying:
Function it allows multiple arguments but it takes one argument at a time.
example:
function add(a) {
  return function(b) {
    return a + b;
  }
}
console.log(add(5)(3));

Lazy evaluation: It delaying the executed value until it is actually required.
It does not run immediately
example:
function* numbers() {
  console.log("Value generated!");
  yield 10;
}
const n = numbers();
console.log(n.next().value);


Types: 1.Callback function
       2.Function return another function
       3.map
       4.filter
       5.reduce
       6.forEach
       7.find
       8.sort

CALLBACK FUNCTION:
Callback is a function that function passes an argument to another function, execute it later.

example:
function greet(name) {
  console.log("Hello " + name);
}
function UserInput(callback) {
  const user = "ABhi";
  callback(user);
}
UserInput(greet);


FUNCTION CALL ANOTHER FUNCTION:
A higher-order function can return another function.

Example:
function func1(x) {
  return function(y) {
    return x * y;
  }
}
const double = func1(2);
console.log(double(10));

Real world example Discount generator:
function discountGenerator(rate) {
  return function(price) {
    return price - (price * rate);
  }
}
const studentDiscount = discountGenerator(0.10);
console.log(studentDiscount(500));


map():
Creates a new array by transforming each element.
example:
const number = [1,2,3];
const squares = number.map(n => n * n);
console.log(squares);

Real world example GST calculator:
const prices = [100, 200, 300];
const finalPrices = prices.map(price => price + price * 0.18);
console.log(finalPrices);

filter():
Returns elements that match a condition.
or
The resulted elements are copied from the original elements.
It will not give new elements.

example:
const num1 = [5,6,7,8,9,10];
const filtered = num1.filter(n => n > 8);
console.log(filtered);

Real time E-commerce product price:
const products = [
  { name: "Mouse", price: 400 },
  { name: "Keyboard", price: 800 },
  { name: "SSD", price: 500 }
];
const budgetItems = products.filter(p => p.price <= 600);
console.log(budgetItems);


reduce():
Reduce used to multiple values into single value. Performs sum operation.
example:
const num2 = [1,2,3,4,5];
const sum = num2.reduce((acc, val) => acc + val, 0);
console.log(sum);

Real time example cart total calculate:
const cart = [
  { price: 200 },
  { price: 400 },
  { price: 150 }
];
const total = cart.reduce((acc, item) => acc + item.price, 0);
console.log(total);
op is total price of all product


forEach(): Runs a function for every element (no return value).
example:
const numbers = [1,2,3,4,5];
numbers.forEach(num => {
  console.log(num);
});

Real world example Display products:
const products = ["Shoes", "Keyboard", "Watch", "Bag"];
products.forEach(item => {
  console.log("Product:", item);
});



find(): Returns the first element that matches a condition.
example:
const num3 = [4,7,10];
const result = num3.find(n => n > 5);
console.log(result);

Realtime example select employee:
const employees = [
  { name: "emp1", email: "emp1@gmail.com" },
  { name: "emp2", email: "emp2@gmail.com" }
];
const emp = employees.find(e => e.name === "emp1");
console.log(emp);


sort: Arrange elements ascending or descending manner.
example:
const numbers = [5, 1, 8, 3];
numbers.sort((a, b) => a - b);
console.log(numbers);

Real time example sort students name:
const students = ["Raj", "Pavan", "Amit", "Neha"];
students.sort();
console.log(students);

Advantages:
Codes cleaner and shorter
Reusability
less errors

Disadvantages:
Callback hell
Complex debugging
Over use makes confusing



2. this Keyword:
this is a special type of keyword, refers to the object that is currently executing the code.
Value of this not depend on where function is, it depends on function is called

Types of this function: 1.Default Binding - Normal function
                        2.Implicit Binding - function called using an object
                        3.Explicit Binding - call(), apply(), bind()
                        4.New Binding - this with constructor
                        5.this with arrow function
                        6.this with DOM


Default binding(Regular or Normal function call):
In this function call refers to global object.
example:
function showName() {
  console.log(this.name);
}
const name = "Bengaluru";
showName();


Implicit Binding - function called using an object:
this refers to object
(object.method())
example:
const person = {
  name: "Amar",
  age: 24,
  showName: function () {
    console.log(this.name);
    console.log(this.age);
  }
};
person.showName();


Explicit binding call(), apply(), bind():

call(): Call a function with specific this value
example:
function greet() {
  console.log("Hello " + this.name);
}
const user = { name: "Rocky" };
greet.call(user);


apply(): Similar to call function, arguments should be in array.
example:
function fun1(city, age) {
  console.log(this.name + " from " + city + ", age " + age);
}
const user = { name: "Rocky" };
fun1.apply(user, ["Bangaluru", 22]);


bind(): Returns a new function with fixed this keyword
example:
function show() {
  console.log("User: " + this.name);
}
const user = { name: "Rocky" };
const newFunc = show.bind(user);
newFunc();


New binding: this with Constructor & new keyword:
It refers to newly created object

example:
function User(name, age) {
  this.name = name;
  this.age = age;
}
const u1 = new User("Aru", 24);
console.log(u1.name);


this with Arrow function(lexical this):
In this user can take this from outer function.
 example:
 const name = "Bhuvan";
const show = () => {
  console.log(this.name);
};
show();

this with DOM:
example: this refers to button
<button onclick="show(this)">Click</button>
<script>
function show(elem) {
  console.log(elem.innerText); // "Click"
}
</script>

this with class:
class User {
  constructor(name) {
    this.name = name;
  }
  show() {
    console.log(this.name);
  }
}
const u = new User("Amruth");
u.show();

Advantages:
Eliminates the need to repeat object names
Useful for oop's
Perfect for event handling (DOM)
Works well with constructor

Disadvantages:
Context changes depending on how it is called
Hard to understand nested this
Arrow do not have thier own this


3. PROTOTYPE:
prototype important concept of js, it means objects inherit properties
and methods from other objects.
It is also called internal hidden property
accessible as (__proto__)

example:
function Person() {
  this.name = "Pruthvi";
}

Person.prototype.age = 22;
let p = new Person();

console.log(p.name);
console.log(p.age);

Prototype Chaining:
Prototype Chaining in JavaScript, it is the process of searching for properties and methods
in the object's prototype and its ancestor prototypes.

example:
let a = { x: 10 };
let b = Object.create(a);
console.log(b.x);


Prototype inheritance: Prototype inheritance is an object can use properties and
methods of another object through the prototype chain

example:
const animal = {
  eats: true,
};

const dog = {
  barks: true,
};

dog.__proto__ = animal;
console.log(dog.eats);
console.log(dog.barks);

Advantages:
Less memory usage
Supports inheritance

Disadvantages:
Long chain works slowly
Accidental Overriding



