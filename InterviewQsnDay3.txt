21. Closures advantages and disadvantages:
Closure: A closure is a feature in JavaScript where a function has access to its outer function's scope, even after the outer function has finished executing. This allows for maintaining state and creating private variables within functions.

Advantages:
Encapsulation: Helps in creating private variables inaccessible from outside the function.
Maintain State: Allows functions to remember and access variables even after the function has finished executing.
Data Privacy: Helps in creating modular and secure code by encapsulating variables within functions.

Disadvantages:
Memory Consumption: Can lead to memory leaks if closures are not handled properly, as they keep references to outer function's variables.
Complexity: Overuse of closures can lead to complex code that is difficult to debug and understand.

Closure:-
A closure is a function that has access to its own scope, the outer function's scope, and the global scope.
Closures are useful for maintaining state in an application, creating private variables, and implementing data encapsulation

example:
function outer() {
    let count = 0;

function inner() {
    count++;
    console.log("Count:", count);
}

return inner;
}

const counter = outer();
counter();
counter();
counter();



22. HOISTING
Hoisting is a JavaScript mechanism where variable and function declarations are moved to the
top of their containing scope during the compilation phase, before the code is executed

examples:-
greet();

function greet() {
    console.log("Hello!")
}   op is Hello!


var a = 1;
let b = 2;
const c = 3;
console.log(a);
console.log(b);
console.log(c);

function demo() {
    console.log(a);
    var a = 30;

    function a() {
        console.log("Hi");
    }
    console.log(a);
}
demo();




23. Promises:
Promises are objects that represent the eventual completion or failure of an asynchronous
operation. They have methods like then() and catch() to handle the result or error of the
operation

examples:
let myPromise = new Promise((resolve, reject) => {
    let success = true;

    if (success) {
        resolve("Task completed!");
    } else {
        reject("Task failed!");
    }
});

myPromise
    .then(result => console.log(result))
    .catch(error => console.log(error));

let myPromise = new Promise((resolve, reject) => {
    let success = false;

    if (success) {
        resolve("Task completed!");
    } else {
        reject("Task failed!");
    }
});

error handling with promises:
myPromise
    .then(result => console.log(result))
    .catch(error => console.log(error));

let promise = new Promise((resolve, reject) => {
    reject("Something went wrong!");
});

promise
    .then(res => console.log(res))
    .catch(err => console.log("Error:", err))
    .finally(() => console.log("Done!"));



24. Cookies and session:
Cookies: Cookies are small pieces of data stored in the user's browser by websites. They are
used to store user-specific information, such as login credentials, preferences, or shopping
cart items.

Sessions: Sessions are server-side data storage mechanisms used to store information about a
user across multiple pages or visits. They are often used to maintain user authentication state
and store temporary data during a user's session.



25. Normal and Arrow function:
Normal:
Normal Function:
Has its own this context.
arguments object is available.
Cannot be used as constructors.
Can be named or anonymous.

example:
function add(a, b) {
    return a + b;
}
console.log(add(5, 10)); op is 15

Arrow:
Does NOT have its own this
Does NOT have arguments
Cannot be used as a constructor
Best for small callback functions
Shorter and cleaner syntax

example:
const add = (a, b) => a + b;
console.log(add(5, 10)); op is 15


let person = {
    name: "ABC",
    show: function () {
        console.log(this.name); // Works
    }
};

person.show();


let person = {
    name: "ABC",
    show: () => {
        console.log(this.name);
    }
};

person.show();  // undefined


function test() {
    console.log(arguments);
}
test(1, 2, 3);



26. How handle single-thread concurrency:
Single-thread concurrency in JavaScript can be handled using asynchronous programming
techniques like callbacks, Promises, async/await, and using features like setTimeout and
setInterval to perform tasks asynchronously.

example:
console.log("Start");
setTimeout(() => {
    console.log("Timeout finished");
}, 2000);
console.log("End");


console.log("1. Start");
setTimeout(() => {
    console.log("2. Timeout complete");
}, 1000);
fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then(() => console.log("3. API response received"));
console.log("4. End");



27. Thread pool in js:
Thread pool in JavaScript refers to the mechanism where asynchronous tasks are managed and
executed efficiently by reusing a pool of threads. This allows JavaScript to handle multiple
asynchronous tasks concurrently without blocking the main thread.

example:
const crypto = require("crypto");

console.log("Start");

crypto.pbkdf2("password", "salt", 100000, 512, "sha512", () => {
    console.log("Hash 1 done");
});

crypto.pbkdf2("password", "salt", 100000, 512, "sha512", () => {
    console.log("Hash 2 done");
});

crypto.pbkdf2("password", "salt", 100000, 512, "sha512", () => {
    console.log("Hash 3 done");
});

crypto.pbkdf2("password", "salt", 100000, 512, "sha512", () => {
    console.log("Hash 4 done");
});

console.log("End");



28. Debouncing & Throttling:
Debouncing: Debouncing is a technique used to limit the rate at which a function is executed.
It ensures that the function is only called after a certain amount of time has passed since the
last invocation.

Throttling: Throttling is a technique used to limit the number of times a function can be
called over a specified period. It ensures that the function is called at most once in a given
timeframe.

Example:
debouncing
function debounce(func, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}
function searchData() {
  console.log("Searching...");
}
const debouncedSearch = debounce(searchData, 500);
document.getElementById("input").addEventListener("keyup", debouncedSearch);

Throttling:
function throttle(func, limit) {
  let lastCall = 0;
  return function(...args) {
    const now = Date.now();
    if (now - lastCall >= limit) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}
function onScroll() {
  console.log("Scrolled");
}
const throttledScroll = throttle(onScroll, 1000);
window.addEventListener("scroll", throttledScroll);



29. Capturing and Bubbling:
Capturing: Capturing is the phase in event propagation where the event is first captured by
the outermost element and then propagated inward to the target element.

Bubbling: Bubbling is the phase in event propagation where the event is first handled by the
target element and then propagated outward to the outermost element.

example:
Capturing:
document.addEventListener("click", () => {
    console.log("Document Capturing");
}, true);

document.getElementById("div1").addEventListener("click", () => {
    console.log("DIV Capturing");
}, true);

document.getElementById("btn").addEventListener("click", () => {
    console.log("Button Capturing");
}, true);

Bubbling:
function throttle(func, limit) {
  let lastCall = 0;

  return function(...args) {
    const now = Date.now();

    if (now - lastCall >= limit) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}
window.addEventListener("scroll", throttle(() => {
  console.log("Scrolled!");
}, 1000));



30. Prototype:
Prototype: In JavaScript, each object has a prototype, which serves as a template for creating
new objects. It allows objects to inherit properties and methods from other objects.

example:
const person = {
  greet() {
    console.log("Hello!");
  }
};
const student = {
  name: "XYZ"
};
student.__proto__ = person;
console.log(student.name);
student.greet();

prototype with constructor:
function User(name, age) {
  this.name = name;
  this.age = age;
}
// Adding method using prototype
User.prototype.sayHello = function () {
  console.log(`Hello, I'm ${this.name}`);
};
const u1 = new User("ABC", 22);
const u2 = new User("DEF", 25);
u1.sayHello();
u2.sayHello();



31. Prototype inheritance:
Prototype Chaining: Prototype chaining is the process of traversing the prototype chain to
access properties and methods of an object's prototype and its parent prototypes. It allows
objects to inherit properties and methods from multiple levels of the prototype chain.

example:
function Animal() {}
Animal.prototype.eat = function () {
  console.log("Eating...");
};
function Dog() {}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.bark = function () {
  console.log("Barking...");
};
const d = new Dog();
d.eat();   // inherited
d.bark();  // Dog method
